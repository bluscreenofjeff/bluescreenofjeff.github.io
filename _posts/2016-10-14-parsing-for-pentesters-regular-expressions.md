---
layout: post
title: Parsing for Pentesters - Regular Expressions
summary: An introduction to using regular expressions focused on penetration tester or red teamer use.
tags: 
- parsing
featuredimage: /assets/parsing_post_2/example_2.png
---


In a [previous post]({{site.baseurl}}/2016-07-26-finding-diamonds-in-the-rough-parsing-for-pentesters/), [@Sw4mp_f0x](https://twitter.com/Sw4mp_f0x) and I discussed the importance of data parsing skills for penetration testers and detailed the basics of how to get started with it. In that post we covered multiple ways to match text and search for specific strings. The examples we used were pretty straightforward, which is not always true to life. In this post we will cover more advanced pattern matching with regular expressions, giving you even greater control and flexibility over your parsing tools.

# Regular Expressions

A regular expression, often referred to as regex, uses metacharacters, wildcards, and literal characters to define patterns that can be used with a wide range of Unix and Windows tools. Sounds simple, right? Regular expressions can prove to be difficult, especially when just starting out. Luckily, there are a wealth of resources to help out in a pinch. To complicate things even further, regex syntax will vary by tool or programming language. For example, regex developed for use in Python may not work in awk.

To use an overly-simplified example, let’s say we want to write a regex to match the words car and cat. Logically, you would want to match a word that starts with the letters *c* and *a* and ended with the letters *r* or *t*. In regular expression syntax, that looks like:
<div style="background-color:rgb(39,40,34);color:rgb(248,248,242);font-size:.85em;overflow-x:scroll;white-space: nowrap;padding:6px;font-family: Consolas, monaco, monospace;">
<span style="color: dodgerblue">^</span>ca<span style="color: mediumseagreen">[rt]</span><span style="color: tomato">$</span></div>


Syntax explanation:
<div style="background-color:rgb(39,40,34);color:rgb(248,248,242);font-size:.85em;overflow-x:scroll;white-space: nowrap;padding:6px;font-family: Consolas, monaco, monospace;">
Match if <span style="color: dodgerblue">a line starts with</span>the literal string "ca"<br>
and is followed by <span style="color: mediumseagreen">the letters "r" or "t"</span> <span style="color: tomato">at the end of the line</span>.</div>

Here is a table with common metacharacters supported by awk and sed:

<div>
<style>
th, td {
    padding: 15px;
}
table, th, td {
    border: 1px solid black;
}
</style>
<table style="width:100%;">
 <tr><th style="text-align:center;">Character</th><th style="text-align:center;">Description</th></tr>
 	<tr><td style="text-align:center;">.</td><td>Matches any single character (or newline)</td></tr>
 	<tr><td style="text-align:center;">*</td><td>Matches preceding character or metacharacter <b>zero</b> or more times</td></tr>
	<tr><td style="text-align:center;">\</td><td>Escapes a special character, causing the tool to treat the following character as literal. When in doubt, escape it.</td></tr>
	<tr><td style="text-align:center;">^</td><td>Matches the beginning of a line </td></tr>
	<tr><td style="text-align:center;">$</td><td>Matches the end of a line</td></tr>
	<tr><td style="text-align:center;">\b</td><td>Word boundary (beginning or end)</td></tr>
	<tr><td style="text-align:center;">[...]</td><td>Matches any one of the characters contained within the brackets. Also supports a range, such as [0-9] or [a-zA-Z]. You can also match character types by specifying a <a href="https://www.gnu.org/software/gawk/manual/gawk.html#Bracket-Expressions">character class</a></td></tr>
	<tr><td style="text-align:center;">[^...]</td><td>Does <b>not</b> match any of the included characters or ranges. <br>The opposite of [...]</td></tr>
	<tr><td style="text-align:center;">+</td><td>Matches preceding character or metacharacter <b>one</b> or more times 
		<br><i>(Extended metacharacter)</i></td></tr>
	<tr><td style="text-align:center;">?</td><td>Matches the preceding character <b>zero</b> or <b>one</b> time
		<br><i>(Extended metacharacter)</i></td></tr>
	<tr><td style="text-align:center;">|</td><td>Acts as a logical OR on multiple regular expressions
		<br><i>(Extended metacharacter)</i></td></tr>
	<tr><td style="text-align:center;">(...)</td><td>Used to group regular expressions, such as when using the | metacharacter. Expression matches within a group  can be called later on.
		<br><i>(Extended metacharacter)</i></td></tr>
	<tr><td style="text-align:center;">(?:..)</td><td>Passive group. The value of the expression match is not stored for later reference
	<br><i>(Extended metacharacter)</i></td></tr>
	<tr><td style="text-align:center;">{...}</td><td>Denotes a range for the previous character. Follows one of the three following formats:
	<ul>
		<li>{x} - matches x occurrences of the preceding character or regex</li>
		<li>{x,} - matches x or more occurrences of the preceding character or regex</li>
		<li>{x,y} - matches from x to y occurrences of the preceding character or regex</li>
	</ul>
<i>(Extended metacharacter)</i></td></tr>
</table><br>
</div>

For more detailed information about these metacharacters, see the [GNU Awk User’s Guide](https://www.gnu.org/software/gawk/manual/gawk.html#Regexp-Operators).

It’s important to note that not all metacharacters are supported by all tools, particularly those marked *extended metacharacter* above. If you are running into errors or improper matching, check that the syntax is supported by the tool or operating system you’re using. When working with grep, make sure to use the `-E` switch to enable use of more regex metacharacters, such as the curly brackets. Additionally, in order to use a metacharacter literally, you must escape it with a backslash. Yes, even the backslash itself if you need one in your pattern. 

To really see regular expressions in action, let’s work through a basic example. You have been given several files from your client and told that they contain all of the used IP addresses and IP ranges in their network. They can’t be bothered to format the files into a usable format.

Here is the content of the provided files concatenated into one:

![Example](/assets/parsing_post_2/example_1.png)

Within this file we have individual IP address and IP address ranges and we want to extract both in order to ensure we test everything. We can use grep, awk, or sed to do this. Let’s go with grep for this example. As with many things, there is more than one way to go about this. We use the `-o` switch to output anything that matches the regex. Default behavior is to print the entire line that a match is located in. The following will work well for this example:

```bash
grep -o -E '[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}(?:\/[0-9]{1,2})?' Ranges.txt
```

Breakdown:
[0-9]{1,3} - The brackets define a range of characters that will match. Here, any number 0-9 will match. The curly brackets are used to define the number or range of acceptable repetitions of the previous expression. In english, this matches 1 to 3 sequential numbers, which is what an IP address octet will fall into. There are 4 of these expressions in the regex above, one for each octet, separated by an escaped period. The period must be escaped because it is a metacharacter that would otherwise represent any character other than a newline. 

(?:\/[0-9]{1,2})? - With this we provide an optional expression for CIDR notation in the form of a passive group. Passive groups are defined with (?:....). A non-passive group, called a ‘named group’ is different and can be referenced later on. More on this later. The passive grouping allows us to apply a quantifier (+, ?, {}, *) to a group of expressions. Quantifiers apply to the previous expression, in this case a passive group. We use the question mark quantifier to make the entire passive group optional. The group contains an escaped forward slash and 1 to 2 digits (0-9), just like we did for the octets. 

Let’s take a look at this in action:

![Example](/assets/parsing_post_2/example_2.png)

This meets our needs for this case, but can be prone to false positives. For example, the invalid IP address 10.0.15.467 would match with this regex. Let’s make this a little more granular using a couple more metacharacters. First, I have inserted a couple of invalid IP addresses.

![Example](/assets/parsing_post_2/example_3.png)

![Example](/assets/parsing_post_2/example_4.png)

As you can see, our current expression happily matches the invalid IP addresses. The first thing we can do is be more specific with what numbers are allow. We can use the `|` metacharacter to give the expression several options to match for each octet:

```bash
(?:25[0-5]|2[0-4][0-9]|1[0-9]{2}|[0-9]{2}|[1-9])\. 
```

Within this passive group, there are five possible expressions that can be match for each octet: 
* 25[0-5] 	(250-255) 
* 2[0-4][0-9] 	(200-249)
* 1[0-9]{2}	(100-199)
* [0-9]{2}		(10-99)
* [0-9] or [1-9]	(0-9 or 1-9 for the first octet)

Including these inside a passive group and separating them with an ‘or’ metacharacter `|` creates an expression that will match the values you would expect from a valid octet, 0-255 or 1-255 for the first octet. Now if we replace our <span style="color: mediumseagreen;">octet expressions</span> used so far, we get a much longer regex that eliminates most, not all, false positives that may be encountered. Note that the first is slightly different to restrict a ‘0’ value. 

In the previous screenshot, you will see the IP address 999.1.2.3. This will still be accepted as a valid IP address by excluding the first ‘9’. We can prevent this with a <span style="color: dodgerblue">word boundary</span> metacharacter. Similar to the `^` and `$` metacharacters, which matches the start or end of a line respectively, the word boundary metacharacter `\b`  matches the beginning or end of a word. Interestingly, numbers act as words in the context of word boundaries. 

<div style="background-color:rgb(39,40,34);color:rgb(248,248,242);font-size:.85em;overflow-x:scroll;white-space: nowrap;padding:6px;font-family: Consolas, monaco, monospace;">
grep -o -E '<span style="color: dodgerblue">\b</span><span style="color: mediumseagreen">(?:25[0-5]|2[0-5][0-9]|1[0-9]{2}|[1-9][0-9]|[1-9])</span>\.(?:<span style="color: mediumseagreen">(?:25[0-5]|2[0-5][0-9]|1[0-9]{2}|[0-9]{1,2})</span>\.){2}<span style="color: mediumseagreen">(?:25[0-5]|2[0-5][0-9]|1[0-9]{2}|[0-9]{1,2})</span>(?:\/[0-9]{1,2})?' Ranges.txt</div>

The result:

![Example](/assets/parsing_post_2/example_5.png)

# Lookahead and Lookbehind
Lookaheads and lookbehinds determine if a pattern follows or precedes the define regex. Each comes in two flavors: positive (pattern does appear) and negative (pattern does not appear). 
A key difference between lookaheads and lookbehinds is that lookaheads can test for a search pattern or regex, whereas a lookbehind can **only** use a search pattern.

Here is the syntax for each:

<table style="width:100%;border: 1px solid black;text-align:center;">
 <tr><th style="text-align:center;">Description</th><th style="text-align:center;">Syntax</th></tr>
 	<tr><td>Positive Lookahead</td><td><i>(?=string)</i> OR <i>(?=(regex))</i></td></tr>
 	<tr><td>Negative Lookahead</td><td><i>(?!string)</i> OR <i>(?!(regex))</i></td></tr>
 	<tr><td>Positive Lookbehind</td><td><i>(?<=string)</i></i></td></tr>
 	<tr><td>Negative Lookbehind</td><td><i>(?<!string)</i></td></tr>
</table>

Consider the following word list:

```
build
builds
building
buildings
```

Here is a demonstration of using each lookahead and lookbehind to match this list. Note that we are using the `-P` flag with grep. Without that flag, lookaheads and lookbehinds would not work. If you have issues with these, ensure your tool supports lookaheads and lookbehinds.

![Example](/assets/parsing_post_2/lookarounds.png)

# Backreferences

Backreferences allow a regex to match a previously matched pattern earlier in the regex. For example, in the sentence “word is the same as word,” where *word* can be any value but where both occurrences must match. Backreferences rely on capture groups to assign variables properly. A capture group is any regex surrounded by parenthesis. Once capture groups are defined, a backreference is used with the \\*x* metacharacter, where *x* is the capture group number.

To follow the earlier example, the following regex would match only when the first and last words match:

```
(^.*\b) is the same as \1
```

![Example](/assets/parsing_post_2/backreferences.png)

Backreferences can be highly useful in pentesting when parsing structured data formats, such as HTML, XML, or log output.


# Useful Regular Expressions

Here is a table of some regular expressions that may commonly be needed on a pentest/red team:

<style>
#sampleregex {background-color:rgb(39,40,34);color:rgb(248,248,242);font-size:.85em;overflow-x:scroll;white-space: nowrap;padding:6px;font-family: Consolas, monaco, monospace;}
</style>
<table style="width:100%;border: 1px solid black;table-layout: fixed;text-align:center;">
 <tr><th style="text-align:center;width:30%;overflow-x:scroll;">Description</th><th style="text-align:center;">Regular Expression</th></tr>
 	<tr><td>IP Address <br>(with optional CIDR)</td><td><div id="sampleregex">[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}(?:\/[0-9]{1,2})?</div></td></tr>
 	<tr><td>Internal IPv4 Address</td><td><div id="sampleregex">(10\.[0-9]{1,3}|172\.((1[6-9])|(2[0-9])|(3[0-1]))|192\.168)(\.[0-9]{1,3}){2}</div></td></tr>
 	<tr><td>Domain Name from URL<br><i>(Requires Lookarounds)</i></td><td><div id="sampleregex">'\b((?<=https://)|(?<=http://))?[a-zA-Z0-9]*\.[a-zA-Z]+(?=:[0-9]{1,5})?(?=/)?\b</div></td></tr>
 	<tr><td>MAC Address</td><td><div id="sampleregex">([0-9a-fA-F]{2}:){5}[0-9a-fA-F]{2}</div></td></tr>
 	<tr><td>Domain User</td><td><div id="sampleregex">\bDomainName\\\w+</div></td></tr>
 	<tr><td>US Social Security Number</td><td><div id="sampleregex">[0-9]{3}-[0-9]{2}-[0-9]{4}</div></td></tr>
 	<tr><td>US Phone Number</td><td><div id="sampleregex">(\(?[0-9]{3}\)?)? ?[0-9]{3}[-\.]?[0-9]{4}</div></td></tr>
</table>

There are many great resources for finding more specific regular expressions you can use to find pieces of personally identifiable information (PII) related to your testing. Here are a couple more for reference:

* [Credit Cards by Issuer - regular-expressions.info](http://www.regular-expressions.info/creditcard.html)
* [Valid IPv6 Addresses - StackOverflow](http://stackoverflow.com/questions/53497/regular-expression-that-matches-valid-ipv6-addresses)
* [International phone number - StackOverflow](http://stackoverflow.com/questions/2113908/what-regular-expression-will-match-valid-international-phone-numbers)
* [Mobile User Agent - GitHub - dalethedeveloper](https://gist.github.com/dalethedeveloper/1503252)

# Summary

As you can see, pattern matching can quickly get complicated. But, regular expressions are extremely powerful and can save you a lot of time instead of trying to chain multiple tools together on the pipeline. Regular expressions are supported in some form in just about every tool that provides a search function, so learning how to wield them is well worth the time.

# Further References:

* [Regular-expressions.info](http://www.regular-expressions.info/)
* [rexegg.com](http://www.rexegg.com/)
* [Regexr.com](http://regexr.com/)
* [regexpal.com](http://www.regexpal.com/)
* [Regular Expression Language - Quick References - TechNet](https://msdn.microsoft.com/en-us/library/az24scfc(v=vs.110).aspx)

